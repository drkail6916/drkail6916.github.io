---
title: "[Part 2]데이터 사이언스로 가는 첫 걸음"
excerpt: "Ch 11. 함수"
classes: wide

categories:
  - AIFFEL
---
### Ch 11. 함수

예약어(Reserved Words): 특정 기능을 수행하도록 미리 예약이 되어 있는 단어.  
예약어는 **변수명으로 쓸 수 없다**는 점이 중요하다. 이는 Python을 포함하여 모든 프로그래밍 언어의 규칙이다.

Python 3.12.11 기준 35개의 예약어가 있다. 다음의 코드로 확인이 가능하다.

```python
import keyword
keyword.kwlist
```

#### 1. `False`
- 기능
  - 논리 값(Boolean)으로, "거짓"을 나타냄.
  - Python에서 `False`는 `bool` 타입의 값이며, 조건식에서 거짓으로 평가됨.
- 사용법
  - 조건문(`if`, `while`)에서 사용.
  - 비교 연산(`==`, `<`, `>`)이나 논리 연산(`and`, `or`, `not`)의 결과로 반환.
- 예시
  ```python
  x = 5
  if x < 0:
      print("Negative")
  else:
      print("Non-negative")
  ```
- 활용 예시
  - 데이터 필터링: `pandas`에서 조건에 따라 데이터를 필터링 할 때 `False`가 포함된 boolean mask 사용
    ```python
    import pandas as pd

    df = pd.DataFrame({'value': [10,-5,20]})
    mask = df['value'] < 0  # boolean 시리즈: [False, True, False]
    print(df[mask])         # 출력: value가 -5인 행
    ```
- 주의점
  - `False`는 `0`, `None`, 빈 리스트(`[]`), 빈 문자열(`""`) 등과 구분해야 함.  
  이들은 `False`로 평가되지만 동일하지 않다.
    ```python
    print(False == 0)  # 출력: False (False와 0은 타입이 다르다)
    print(bool(0))     # 출력: False (0은 False로 평가됨)
    ```

#### 2. `None`
- 기능
  - "값이 없음"을 나타내는 특수 객체. `NoneType`의 유일한 인스턴스.
  - 변수나 함수가 값을 반환하지 않을 때 사용.
- 사용법
  - 변수 초기화, 함수의 기본 반환값 또는 결측값 표현.
  - `is None` 또는 `is not None`으로 비교.
- 예시
  ```python
  def no_return():
      pass
  
  result = no_return()
  print(result)          # 출력: None
  
  x = None
  if x is None:
      print("No value")  # 출력: No value
  ```
- 활용 예시
  - 결측값 처리: pandas에서 `None`는 `NaN`과 유사하게 결측값으로 처리.
    ```python
    import pandas as pd

    df = pd.DataFrame({'A': [1, None, 3]})
    print(df['A'].isna())  # 출력: [False, True, False]
    ```
- 주의점
  - `None`은 `False`나 `0`과 다르다. `==` 대신 `is`를 사용해 비교.
    ```python
    print(None == False)  # 출력: False
    print(None is False)  # 출력: False
    ```
  - 데이터프레임에서 `None`과 `np.nan`은 상호 변환이 가능하지만, 연산 시 주의 필요.

#### 3. `True`
- 기능
  - 논리 값(Boolean)으로, "참"을 나타냄.
  - 조건식이 참일 때 사용.
- 사용법
  - 조건문, 논리 연산에서 사용.
  - 비교 연산의 결과로 반환.
- 예시
  ```python
  x = 10
  if x > 0:
    print("Positive")  # 출력: Positive (x > 0은 True)
  ```
- 활용 예시
  - Boolean 인덱싱: 데이터프레임에서 조건을 만족하는 행 선택.
    ```python
    import pandas as pd

    df = pd.DataFrame({'value': [10, -5, 20]})
    mask = df['value'] > 0  # boolean 시리즈: [True, False, True]
    print(df[mask])         # 출력: value가 10, 20인 행
    ```
- 주의점
  - `True`는 `1`로 평가될 수 있지만, 데이터의 타입은 다르다.
    ```python
    print(True == 1)  # 출력: True
    print(True is 1)  # 출력: False
    ```

#### 4. `and`
- 기능
  - 논리 연산자. 두 조건이 모두 `True`일 때 `True` 반환.
  - 단락 평가(short-circuit): 첫 번째 조건이 `False`면 두 번째 조건은 평가하지 않음.
- 사용법
  - 조건문에서 복합 조건 구성.
  - `A and B`: A와 B가 모두 참일 때 참.
- 예시
  ```python
  x, y = 5, 10
  if x > 0 and y < 20:
      print("Both true")  # 출력: Both true
  ```
- 활용 예시
  - 복합 필터링: pandas에서 여러 조건을 결합.
    ```python
    import pandas as pd

    df = pd.DataFrame({'A': [1,2,3], 'B': [10,20,30]})
    filtered = df[ (df['A'] > 1) & (df['B'] < 25) ]  # pandas에서는 & 사용
    print(filtered)  # 출력: A=2, B=20인 행
    ```
- 주의점
  - pandas에서는 `and` 대신 `&`를 사용(벡터화 연산).
  - 단락 평가로 인해 두 번째 조건이 실행되지 않을 수 있음.
    ```python
    x = 0
    if x != 0 and 10/x > 2:  # 조건1(x!=0)에서 이미 어긋나기 때문에 조건2(10/x)는 평가되지 않음
        print("Safe")
    ```

#### 5. `as`
- 기능
  - 모듈, 객체, 예외 등을 별칭(alias)으로 지칭.
  - 문맥에 따라 `import`, `with`, `except`에서 사용.
- 사용법
  - `import module as alias`: 모듈에 별칭 부여.
  - `with open(...) as f`: 리소스 관리.
  - `except Exception as e`: 예외 처리 캡쳐.
- 예시
  ```python
  import numpy as np                # numpy를 np로 지칭

  with open('file.txt', 'r') as f:  # file.txt를 f로 지칭
      content = f.read()

  try:
      x = 1 / 0
  except ZeroDivisionError as e:    # ZeroDivisionError를 e로 지칭
      print(e)
  ```
- 활용 예시
  - 모듈 임포트: `pandas as pd`, `numpy as np`와 같이 코드 간결화.
  - 리소스 관리: 대량의 csv 파일 읽기(?)
    ```python
    import pandas as pd

    with open('data.csv', 'r') as f:
        df = pd.read_csv(f)
    ```
- 주의점
  - 별칭은 명확하고 표준적인 이름(예: `pd`, `np`)을 사용하는 것이 좋음.
  - `with` 문에서 `as`로 지정한 객체는 블록 종료 후 자동 해제.

#### 6. `assert`
- 기능
  - 조건이 `True`인지 확인하고, `False`면 `AssertionError` 발생.
  - 디버깅 및 테스트에 사용.
- 사용법
  - `assert condition, message`: 조건이 거짓이면 메세지와 함께 에러 발생.
- 예시
  ```python
  x = 5
  assert x < 0, "x is not positive"
  print("x is positive")  # 출력: x is not positive
  ```
- 활용 예시
  - 데이터 검증: 데이터 전처리 시 값의 유효성 확인.
    ```python
    import pandas as pd

    df = pd.DataFrame({'age': [25,-5,30]})
    assert (df['age'] >= 0).all(), "Negative age detected"
    ```
- 주의점
  - 프로덕션 코드에서는 `assert`가 비활성화 될 수 있음(`-0` 플래그 사용 시).
  - 복잡한 검증에는 `if-raise`가 더 적합함.

#### 7. `async`
- 기능
  - 비동기 함수를 정의. 코루틴(coroutine)을 생성함.
  - 비동기 프로그래밍(`asyncio`)에 사용.
- 사용법
  - `async def`: 비동기 함수 정의.
  - `await`와 함께 사용.
- 예시
  ```python
  import asyncio

  async def say_hello():
      await asyncio.sleep(1)
      print("Hello")

  asyncio.run(say_hello())  # 출력: Hello (1초 후)
  ```
- 활용 예시
  - 비동기 데이터 수집: API 호출, 대량 파일 읽기.
    ```python
    import aiohttp
    import asyncio

    async def fetch_data(url):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()

    asyncio.run(fetch_data('https://api.example.com/data'))
    ```
- 주의점
  - `async` 함수는 `await`로 호출해야 하며, 일반 함수처럼 호출 시 코루틴 객체 반환.
  - 데이터사이언스에서는 비동기 프로그래밍이 드물지만, I/O 작업에서 유용.

#### 8. `await`
- 기능
  - 비동기 함수 내에서 코루틴의 실행을 기다림.
  - `async` 함수 내에서만 사용 가능.
- 사용법
  - `await expression`: 비동기 작업 완료까지 대기.
- 예시
  ```python
  import asyncio

  async def main():
      await asyncio.sleep(1)
      print("Done")
  
  asyncio.run(main())  # 출력: Done (1초 후)
  ```
- 활용 예시
  - 병렬 데이터 처리: 여러 API 호출을 병렬로 처리.
    ```python
    async def fetch_all(urls):
        tasks = [ fetch_data(url) for url in urls ]
        return await asyncio.gather(*tasks)
    ```
- 주의점
  - `await`는 `async` 함수 내에서만 사용 가능.
  - 비동기 작업이 많지 않은 데이터사이언스에서는 사용 빈도 낮음.

#### 9. `break`
- 기능
  - 반복문(`for`, `while`)을 즉시 종료.
- 사용법
  - 조건이 충족되면 반복문 탈출.
- 예시
  ```python
  for i in range(5):
      if i == 5:
          break
      print(i)  # 출력: 0, 1, 2, 3, 4
  ```
- 활용 예시
  - 데이터 탐색: 조건 만족 시 데이터 처리 중단.
    ```python
    import pandas as pd

    df = pd.DataFrame({'value': [1,2,-999,4]})
    for idx, row in df.iterrows():
        if row['value'] == -999:
            print("Invalid data found")
            break
    ```
- 주의점
  - `break`는 가장 가까운 반복문만 종료.
  - `iterrows()`는 느리므로 대량 데이터에서는 벡터화 선호.

#### 10. `class`
- 기능
  - 사용자 정의 클래스를 정의.
  - 객체 지향 프로그래밍의 핵심.
- 사용법
  - `class Name:`으로 새로운 클래스 정의.
- 예시
  ```python
  class DataProcessor:
      def __init__(self, data):
          self.data = data

      def process(self):
          return [ x * 2 for x in self.data ]

  processor = DataProcessor( [1,2,3] )
  print(processor.process())  # 출력: [2, 4, 6]
  ```
- 활용 예시
  - 파이프라인 정의: 데이터 전처리 및 모델링 파이프라인을 클래스화.
    ```python
    class DataCleaner:
        def __init__(self, df):
            self.df = df
        
        def clean(self):
            self.df = self.df.dropna()
            return self.df
    ```
- 주의점
  - 클래스 이름은 대문자로 시작하는 것이 관례.
  - 데이터사이언스에서는 `scikit-learn` 같은 라이브러리의 클래스 활용 빈도가 높음.

#### 11. `continue`
- 기능
  - 반복문의 현재 반복을 건너뛰고 다음 반복으로 진행.
- 사용법
  - 조건이 충족되면 현재 반복 종료.
- 예시
  ```python
  for i in range(5):
      if i == 2:
          continue
      print(i)  # 출력: 0, 1, 3, 4
  ```
- 활용 예시
  - 데이터 필터링: 특정 조건의 데이터 무시.
    ```python
    for idx, row in df.iterrows():
        if pd.isna(row['value']):
            continue
        print(row['value'])
    ```
- 주의점
  - 과도한 사용은 코드 가독성 저하.
  - 벡터화로 대체 가능 시 선호.

#### 12. `def`
- 기능
  - 함수를 정의.
- 사용법
  - `def function_name(params):`으로 함수 선언.
- 예시
  ```python
  def square(x):
      return x * x

  print(square(5))  # 출력: 25
  ```
- 활용 예시
  - 데이터 변환: 사용자 정의 함수로 데이터 처리.
    ```python
    def standardize(x):
        return (x - x.mean()) / x.std()

    df['standardized'] = standardize(df['value'])
    ```
- 주의점
  - 함수는 명확한 이름과 주석으로 가독성 유지.
  - 대량의 데이터에서는 벡터화 함수 선호.

#### 13. `del`
- 기능
  - 객체(변수, 리스트 요소 등)를 삭제.
- 사용법
  - `del obj`: 메모리에서 객체 제거.
- 예시
  ```python
  x = [a, b, c]
  del x[1]
  print(x)  # 출력: [a, c]
  ```
- 활용 예시
  - 메모리 관리: 데이터프레임의 불필요한 컬럼 삭제
    ```python
    del df['unused_column']
    ```
- 주의점
  - 삭제된 객체 참조 시 `NameError`.
  - pandas에서는 `drop()` 메서드 선호.

#### 14. `elif`
- 기능
  - 조건문에서 추가 조건을 검사.
  - `if`와 `else` 사이에 사용.
- 사용법
  - `if condition: ... elif condition ...`.
- 예시
  ```python
  x = 0

  if x > 0:
      print("Positive")
  elif x == 0:
      print("Zero")  # 출력: Zero
  else:
      print("Negative")
  ```
- 활용 예시
  - 카테고리 분류: 값을 범주로 변환.
    ```python
    def categorize(x):
        if x > 100:
            return 'High'
        elif x > 50:
            return 'Medium'
        else:
            return 'Low'
      
    df['category'] = df['value'].apply(categorize)
    ```
- 주의점
  - 너무 많은 `elif`는 가독성 저하. 딕셔너리 매핑이나 `numpy.select` 고려.

#### 15. `else`
- 기능
  - 조건문, 반복문, 예외 처리에서 기본 경로 지정.
- 사용법
  - `if ... else`, `for ... else`, `try ... else`
- 예시
  ```python
  x = 10
  if x < 0:
      print("Negative")
  else:
      print("Non-negative")  # 출력: Non-negative
  ```
- 활용 예시
  - 조건 처리: 데이터 전처리에서 기본값 설정.
    ```python
    df['value'] = df['value'].apply(lambda x: x if x > 0 else 0)
    ```
- 주의점
  - `for ... else`는 반복문이 `break` 없이 완료될 때 사용. 초보자가 혼동하기 쉬움.

#### 16. `except`
- 기능
  - 예외 처리 블록 정의.
  - `try` 블록에서 발생한 예외를 캡쳐.
- 사용법
  - `try: ... except Exception: ...`.
- 예시
  ```python
  try:
      x = 1 / 0
  except ZeroDivisionError:
      print("Can't divide by zero")  # 출력
  ```
- 활용 예시
  - 데이터 로드 에러 처리: 파일 읽기 실패 시 대체 로직.
    ```python
    try:
        df = pd.read_csv('data.csv')
    except:
        print("File not found")
        df = pd.DataFrame()
    ```
- 주의점
  - 특정 예외를 명시적으로 처리(예: `ZeroDivisionError`).
  - `except`만 사용하면 모든 예외 캡쳐, 디버깅 어려움.

#### 17. `finally`
- 기능
  - 예외 처리에서 항상 실행되는 블록.
  - `try` 블록 종료 후 정리 작업.
- 사용법
  - `try: ... finally: ...`.
- 예시
  ```python
  try:
      f = open('file.txt', 'r')
  except FileNotFoundError:
      print("File not found")
  finally:
      f.close()  # 항상 실행
  ```
- 활용 예시
  - 리소스 정리: 파일, 데이터베이스 연결 닫기.
    ```python
    try:
        df = pd.read_csv('large_file.csv')
    finally:
        print("Processing complete")
    ```
- 주의점
  - `finally`는 예외 발생 여부와 관계없이 실행.
  - 리소스 관리는 `with`문 선호.

#### 18. `for`
- 기능
  - 반복문으로, 이터러블 객체를 순회.
- 사용법
  - `for item in iterable: ...`.
- 예시
  ```python
  for i in range(5):
      print(i)  # 출력: 0, 1, 2, 3, 4
  ```
- 활용 예시
  - 데이터 처리: 데이터프레임 행 순회(벡터화 선호).
    ```python
    for idx, row in df.iterrows():
        print(row['value'])
    ```
- 주의점
  - 대량의 데이터에서는 `iterrows()`보다 벡터화(`apply`, `numpy`) 선호.
  - 이터러블이 아닌 객체 사용 시 `TypeError`.

#### 19. `from`
- 기능
  - 모듈, 패키지, 객체를 임포트.
- 사용법
  - `from module import name`.
- 예시
  ```python
  from math import sqrt

  print(sqrt(16))  # 출력: 4.0
  ```
- 활용 예시
  - 라이브러리 임포트
    ```python
    from sklearn.linear_model import LinearRegression
    ```
- 주의점
  - 네임스페이스 충돌 주의(예: 동일 이름의 변수).
  - 불필요한 임포트는 메모리 낭비.

#### 20. `global`
- 기능
  - 전역 변수를 함수 내에서 수정.
- 사용법
  - `global var`로 전역 변수 선언.
- 예시
  ```python
  x = 0

  def increment():
      global x
      x += 1
  
  increment()
  print(x)  # 출력: 1
  ```
- 활용 예시
  - 드물게 사용. 전역 설정값 관리 시 유용.
    ```python
    global_model = None

    def set_model():
        global global_model
        global_model = LinearRegression()
    ```
- 주의점
  - 전역 변수 남용은 코드 유지보수 어려움.
  - 클래스나 매개변수로 대체 권장.

#### 21. `if`
- 기능
  - 조건에 따라 코드 실행.
- 사용법
  - `if condition: ... `.
- 예시
  ```python
  x = 10
  if x > 0:
      print("Positive")  # 출력: Positive
  ```
- 활용 예시
  - 데이터 필터링: 조건에 따른 데이터 처리.
    ```python
    df['is_positive'] = df['value'].apply(lambda x: 1 if x > 0 else 0)
    ```
- 주의점
  - 복잡한 조건은 가독성을 위해 분리.
  - 벡터화로 성능 최적화.